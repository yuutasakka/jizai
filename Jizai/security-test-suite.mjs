#!/usr/bin/env node

/**
 * JIZAI „Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà
 * Êú¨Áï™„Éá„Éó„É≠„Ç§Ââç„ÅÆ„Çª„Ç≠„É•„É™„ÉÜ„Ç£Áõ£Êüª„Å®„Éö„Éç„Éà„É¨„Éº„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà
 */

import { execSync } from 'child_process';
import { readFileSync, existsSync, readdirSync, statSync } from 'fs';
import { join } from 'path';

// Simple glob implementation for our needs
function simpleGlob(pattern) {
  const files = [];
  
  function walk(dir) {
    try {
      const entries = readdirSync(dir);
      for (const entry of entries) {
        const fullPath = join(dir, entry);
        const stat = statSync(fullPath);
        
        if (stat.isDirectory()) {
          walk(fullPath);
        } else {
          files.push(fullPath);
        }
      }
    } catch (error) {
      // Skip directories that can't be read
    }
  }
  
  if (pattern.includes('src/**')) {
    walk('src');
    return files.filter(f => /\.(ts|tsx|js|jsx)$/.test(f));
  } else if (pattern.includes('backend/**')) {
    if (existsSync('backend')) {
      walk('backend');
      return files.filter(f => /\.(js|mjs)$/.test(f));
    }
  }
  
  return files;
}

class SecurityTester {
  constructor() {
    this.results = [];
    this.criticalIssues = [];
    this.warnings = [];
  }

  log(level, test, result, details = '') {
    const entry = { level, test, result, details, timestamp: new Date().toISOString() };
    this.results.push(entry);
    
    const emoji = level === 'CRITICAL' ? 'üö®' : level === 'WARNING' ? '‚ö†Ô∏è' : '‚úÖ';
    const color = level === 'CRITICAL' ? '\x1b[31m' : level === 'WARNING' ? '\x1b[33m' : '\x1b[32m';
    console.log(`${emoji} ${color}${level}\x1b[0m: ${test} - ${result}`);
    if (details) console.log(`   ${details}`);

    if (level === 'CRITICAL') this.criticalIssues.push(entry);
    if (level === 'WARNING') this.warnings.push(entry);
  }

  /**
   * 1. API KeyÈú≤Âá∫„ÉÜ„Çπ„Éà
   */
  async testApiKeyExposure() {
    console.log('\nüîç API KeyÈú≤Âá∫„ÉÜ„Çπ„Éà');
    
    try {
      // „Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Ç≥„Éº„Éâ„Åß„ÅÆAPI keyÊ§úÊüª
      const frontendFiles = simpleGlob('src/**/*.{ts,tsx,js,jsx}');
      const apiKeyPatterns = [
        /eyJ[A-Za-z0-9-_=]+/g,  // JWT tokens
        /sk-[a-zA-Z0-9]{48}/g,  // OpenAI style
        /pk_[a-zA-Z0-9]{24}/g,  // Stripe style
        /(api[_-]?key|secret|token|password)\s*[:=]\s*["'][^"']+["']/gi,
        /DASHSCOPE_API_KEY|SUPABASE_SERVICE_KEY/gi
      ];

      let foundKeys = false;
      for (const file of frontendFiles) {
        const content = readFileSync(file, 'utf8');
        for (const pattern of apiKeyPatterns) {
          const matches = content.match(pattern);
          if (matches) {
            this.log('CRITICAL', 'API Key Exposure', 'FAILED', `Found potential API key in ${file}: ${matches[0].substring(0, 20)}...`);
            foundKeys = true;
          }
        }
      }

      if (!foundKeys) {
        this.log('PASS', 'API Key Exposure', 'PASSED', 'No API keys found in frontend code');
      }

      // Áí∞Â¢ÉÂ§âÊï∞Ë®≠ÂÆöÁ¢∫Ë™ç
      if (existsSync('.env')) {
        const envContent = readFileSync('.env', 'utf8');
        if (envContent.includes('VITE_') && (envContent.includes('api_key') || envContent.includes('secret'))) {
          this.log('CRITICAL', 'Environment Variables', 'FAILED', 'Sensitive data exposed via VITE_ variables');
        } else {
          this.log('PASS', 'Environment Variables', 'PASSED', 'No sensitive data in VITE_ variables');
        }
      }

    } catch (error) {
      this.log('WARNING', 'API Key Exposure', 'ERROR', error.message);
    }
  }

  /**
   * 2. ÂÖ•ÂäõÊ§úË®º„ÉÜ„Çπ„Éà
   */
  async testInputValidation() {
    console.log('\nüîç ÂÖ•ÂäõÊ§úË®º„ÉÜ„Çπ„Éà');

    // „Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ„Ç≥„Éº„Éâ„ÅÆÂÖ•ÂäõÊ§úË®ºÁ¢∫Ë™ç
    try {
      const backendFiles = simpleGlob('backend/**/*.{js,mjs}');
      let hasValidation = false;

      for (const file of backendFiles) {
        const content = readFileSync(file, 'utf8');
        
        // ÂÖ•ÂäõÊ§úË®º„Éë„Çø„Éº„É≥„ÅÆÁ¢∫Ë™ç
        const validationPatterns = [
          /\.trim\(\)\.length\s*[><=]/,  // ÊñáÂ≠óÂàóÈï∑„ÉÅ„Çß„ÉÉ„ÇØ
          /typeof\s+\w+\s*[!=]==?\s*["']string["']/,  // Âûã„ÉÅ„Çß„ÉÉ„ÇØ
          /if\s*\(\s*!\w+\s*\|\|\s*typeof/,  // null/undefined„ÉÅ„Çß„ÉÉ„ÇØ
          /fileFilter|limits|fileSize/,  // „Éï„Ç°„Ç§„É´Ê§úË®º
        ];

        for (const pattern of validationPatterns) {
          if (pattern.test(content)) {
            hasValidation = true;
            break;
          }
        }
      }

      if (hasValidation) {
        this.log('PASS', 'Input Validation', 'PASSED', 'Input validation found in backend code');
      } else {
        this.log('WARNING', 'Input Validation', 'WEAK', 'Limited input validation detected');
      }

    } catch (error) {
      this.log('WARNING', 'Input Validation', 'ERROR', error.message);
    }
  }

  /**
   * 3. XSSËÑÜÂº±ÊÄß„ÉÜ„Çπ„Éà
   */
  async testXSSProtection() {
    console.log('\nüîç XSSËÑÜÂº±ÊÄß„ÉÜ„Çπ„Éà');

    try {
      // CSPË®≠ÂÆöÁ¢∫Ë™ç
      if (existsSync('vercel.json')) {
        const vercelConfig = JSON.parse(readFileSync('vercel.json', 'utf8'));
        const cspHeader = vercelConfig.headers?.find(h => 
          h.headers?.some(header => header.key === 'Content-Security-Policy')
        );

        if (cspHeader) {
          const cspValue = cspHeader.headers.find(h => h.key === 'Content-Security-Policy')?.value;
          
          // Âç±Èô∫„Å™CSPË®≠ÂÆö„Çí„ÉÅ„Çß„ÉÉ„ÇØ
          if (cspValue?.includes("'unsafe-inline'") && cspValue?.includes("'unsafe-eval'")) {
            this.log('WARNING', 'CSP Configuration', 'WEAK', 'Both unsafe-inline and unsafe-eval are allowed');
          } else if (cspValue?.includes("'unsafe-inline'")) {
            this.log('WARNING', 'CSP Configuration', 'WEAK', 'unsafe-inline is allowed');
          } else {
            this.log('PASS', 'CSP Configuration', 'PASSED', 'CSP configured with reasonable restrictions');
          }

          // XSS‰øùË≠∑„Éò„ÉÉ„ÉÄ„ÉºÁ¢∫Ë™ç
          const xssHeader = cspHeader.headers.find(h => h.key === 'X-XSS-Protection');
          if (xssHeader && xssHeader.value.includes('1; mode=block')) {
            this.log('PASS', 'XSS Protection Header', 'PASSED', 'X-XSS-Protection properly configured');
          } else {
            this.log('WARNING', 'XSS Protection Header', 'MISSING', 'X-XSS-Protection not configured');
          }
        } else {
          this.log('CRITICAL', 'CSP Configuration', 'MISSING', 'No Content Security Policy configured');
        }
      }

      // „Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Åß„ÅÆÂç±Èô∫„Å™HTMLÊìç‰ΩúÁ¢∫Ë™ç
      const frontendFiles = simpleGlob('src/**/*.{ts,tsx,js,jsx}');
      let foundDangerousHtml = false;

      for (const file of frontendFiles) {
        const content = readFileSync(file, 'utf8');
        const dangerousPatterns = [
          /dangerouslySetInnerHTML/,
          /innerHTML\s*=/,
          /document\.write/,
          /eval\s*\(/
        ];

        for (const pattern of dangerousPatterns) {
          if (pattern.test(content)) {
            this.log('WARNING', 'Dangerous HTML Manipulation', 'FOUND', `Potentially dangerous HTML manipulation in ${file}`);
            foundDangerousHtml = true;
          }
        }
      }

      if (!foundDangerousHtml) {
        this.log('PASS', 'Dangerous HTML Manipulation', 'PASSED', 'No dangerous HTML manipulation found');
      }

    } catch (error) {
      this.log('WARNING', 'XSS Protection', 'ERROR', error.message);
    }
  }

  /**
   * 4. CORSË®≠ÂÆö„ÉÜ„Çπ„Éà
   */
  async testCORSConfiguration() {
    console.log('\nüîç CORSË®≠ÂÆö„ÉÜ„Çπ„Éà');

    try {
      const backendFiles = simpleGlob('backend/**/*.{js,mjs}');
      let corsConfigFound = false;

      for (const file of backendFiles) {
        const content = readFileSync(file, 'utf8');
        
        if (content.includes('cors') && content.includes('origin')) {
          corsConfigFound = true;
          
          // Âç±Èô∫„Å™CORSË®≠ÂÆö„Çí„ÉÅ„Çß„ÉÉ„ÇØ
          if (content.includes('origin: true') || content.includes('origin: "*"')) {
            this.log('CRITICAL', 'CORS Configuration', 'FAILED', 'Wildcard CORS origin allows all domains');
          } else if (content.includes('allowedOrigins') || content.includes('ORIGIN_ALLOWLIST')) {
            this.log('PASS', 'CORS Configuration', 'PASSED', 'CORS properly restricted to allowed origins');
          } else {
            this.log('WARNING', 'CORS Configuration', 'UNCLEAR', 'CORS configuration needs review');
          }

          // credentialsË®≠ÂÆöÁ¢∫Ë™ç
          if (content.includes('credentials: true')) {
            if (content.includes('origin: "*"')) {
              this.log('CRITICAL', 'CORS Credentials', 'FAILED', 'credentials: true with wildcard origin is dangerous');
            } else {
              this.log('PASS', 'CORS Credentials', 'PASSED', 'credentials properly configured with restricted origins');
            }
          }
        }
      }

      if (!corsConfigFound) {
        this.log('WARNING', 'CORS Configuration', 'MISSING', 'No CORS configuration found');
      }

    } catch (error) {
      this.log('WARNING', 'CORS Configuration', 'ERROR', error.message);
    }
  }

  /**
   * 5. „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà
   */
  async testFileUploadSecurity() {
    console.log('\nüîç „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà');

    try {
      const backendFiles = simpleGlob('backend/**/*.{js,mjs}');
      let uploadConfigFound = false;

      for (const file of backendFiles) {
        const content = readFileSync(file, 'utf8');
        
        if (content.includes('multer')) {
          uploadConfigFound = true;

          // „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫Âà∂ÈôêÁ¢∫Ë™ç
          if (content.includes('fileSize:') || content.includes('limits:')) {
            this.log('PASS', 'File Size Limits', 'PASSED', 'File size limits configured');
          } else {
            this.log('CRITICAL', 'File Size Limits', 'MISSING', 'No file size limits found');
          }

          // „Éï„Ç°„Ç§„É´„Çø„Ç§„ÉóÂà∂ÈôêÁ¢∫Ë™ç
          if (content.includes('fileFilter') && content.includes('mimetype')) {
            this.log('PASS', 'File Type Filtering', 'PASSED', 'File type filtering implemented');
          } else {
            this.log('CRITICAL', 'File Type Filtering', 'MISSING', 'No file type filtering found');
          }

          // Âç±Èô∫„Å™„Éï„Ç°„Ç§„É´„Çø„Ç§„Éó„ÉÅ„Çß„ÉÉ„ÇØ
          if (content.includes('application/') && !content.includes('image/')) {
            this.log('WARNING', 'Dangerous File Types', 'ALLOWED', 'Non-image file types may be allowed');
          }
        }
      }

      if (!uploadConfigFound) {
        this.log('WARNING', 'File Upload Security', 'MISSING', 'No file upload configuration found');
      }

    } catch (error) {
      this.log('WARNING', 'File Upload Security', 'ERROR', error.message);
    }
  }

  /**
   * 6. „É¨„Éº„ÉàÂà∂Èôê„ÉÜ„Çπ„Éà
   */
  async testRateLimiting() {
    console.log('\nüîç „É¨„Éº„ÉàÂà∂Èôê„ÉÜ„Çπ„Éà');

    try {
      const backendFiles = simpleGlob('backend/**/*.{js,mjs}');
      let rateLimitFound = false;

      for (const file of backendFiles) {
        const content = readFileSync(file, 'utf8');
        
        if (content.includes('rateLimit') || content.includes('express-rate-limit')) {
          rateLimitFound = true;

          // „É¨„Éº„ÉàÂà∂ÈôêË®≠ÂÆöÁ¢∫Ë™ç
          const windowMatches = content.match(/windowMs:\s*(\d+)/g);
          const maxMatches = content.match(/max:\s*(\d+)/g);

          if (windowMatches && maxMatches) {
            this.log('PASS', 'Rate Limiting', 'PASSED', `Rate limiting configured: ${windowMatches.length} limiters found`);
          } else {
            this.log('WARNING', 'Rate Limiting', 'INCOMPLETE', 'Rate limiting partially configured');
          }

          // ÈöéÂ±§ÁöÑÂà∂ÈôêÁ¢∫Ë™ç
          if (content.includes('editLimiter') || content.includes('purchaseLimiter')) {
            this.log('PASS', 'Tiered Rate Limiting', 'PASSED', 'Multiple rate limit tiers implemented');
          }
        }
      }

      if (!rateLimitFound) {
        this.log('CRITICAL', 'Rate Limiting', 'MISSING', 'No rate limiting found');
      }

    } catch (error) {
      this.log('WARNING', 'Rate Limiting', 'ERROR', error.message);
    }
  }

  /**
   * 7. ‰æùÂ≠òÈñ¢‰øÇËÑÜÂº±ÊÄß„ÉÜ„Çπ„Éà
   */
  async testDependencyVulnerabilities() {
    console.log('\nüîç ‰æùÂ≠òÈñ¢‰øÇËÑÜÂº±ÊÄß„ÉÜ„Çπ„Éà');

    try {
      // npm audit„ÇíÂÆüË°å
      const auditResult = execSync('npm audit --json', { encoding: 'utf8' });
      const auditData = JSON.parse(auditResult);

      if (auditData.metadata) {
        const { vulnerabilities } = auditData.metadata;
        const criticalCount = vulnerabilities.critical || 0;
        const highCount = vulnerabilities.high || 0;
        const moderateCount = vulnerabilities.moderate || 0;

        if (criticalCount > 0) {
          this.log('CRITICAL', 'Dependency Vulnerabilities', 'FOUND', `${criticalCount} critical vulnerabilities`);
        } else if (highCount > 0) {
          this.log('WARNING', 'Dependency Vulnerabilities', 'FOUND', `${highCount} high-severity vulnerabilities`);
        } else if (moderateCount > 0) {
          this.log('WARNING', 'Dependency Vulnerabilities', 'FOUND', `${moderateCount} moderate vulnerabilities`);
        } else {
          this.log('PASS', 'Dependency Vulnerabilities', 'PASSED', 'No high-severity vulnerabilities found');
        }
      }

    } catch (error) {
      // npm audit may exit with non-zero code when vulnerabilities found
      if (error.stdout) {
        try {
          const auditData = JSON.parse(error.stdout);
          const criticalCount = auditData.metadata?.vulnerabilities?.critical || 0;
          const highCount = auditData.metadata?.vulnerabilities?.high || 0;
          
          if (criticalCount > 0 || highCount > 0) {
            this.log('CRITICAL', 'Dependency Vulnerabilities', 'FOUND', 
              `${criticalCount} critical, ${highCount} high-severity vulnerabilities`);
          }
        } catch {
          this.log('WARNING', 'Dependency Vulnerabilities', 'ERROR', 'Could not parse audit results');
        }
      } else {
        this.log('WARNING', 'Dependency Vulnerabilities', 'ERROR', error.message);
      }
    }
  }

  /**
   * 8. „Çª„Ç≠„É•„É™„ÉÜ„Ç£„Éò„ÉÉ„ÉÄ„Éº„ÉÜ„Çπ„Éà
   */
  async testSecurityHeaders() {
    console.log('\nüîç „Çª„Ç≠„É•„É™„ÉÜ„Ç£„Éò„ÉÉ„ÉÄ„Éº„ÉÜ„Çπ„Éà');

    try {
      if (existsSync('vercel.json')) {
        const vercelConfig = JSON.parse(readFileSync('vercel.json', 'utf8'));
        const headers = vercelConfig.headers?.find(h => h.headers)?.headers || [];

        const requiredHeaders = [
          'X-Content-Type-Options',
          'X-Frame-Options', 
          'X-XSS-Protection',
          'Referrer-Policy',
          'Content-Security-Policy'
        ];

        let missingHeaders = [];
        for (const required of requiredHeaders) {
          const found = headers.find(h => h.key === required);
          if (found) {
            this.log('PASS', `Security Header: ${required}`, 'PASSED', `Value: ${found.value}`);
          } else {
            missingHeaders.push(required);
          }
        }

        if (missingHeaders.length > 0) {
          this.log('WARNING', 'Security Headers', 'INCOMPLETE', `Missing: ${missingHeaders.join(', ')}`);
        } else {
          this.log('PASS', 'Security Headers', 'PASSED', 'All required security headers configured');
        }
      }

    } catch (error) {
      this.log('WARNING', 'Security Headers', 'ERROR', error.message);
    }
  }

  /**
   * ÂÖ®„ÉÜ„Çπ„ÉàÂÆüË°å
   */
  async runAllTests() {
    console.log('üîí JIZAI „Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„ÉàÈñãÂßã\n');
    console.log('=' .repeat(60));

    await this.testApiKeyExposure();
    await this.testInputValidation();
    await this.testXSSProtection();
    await this.testCORSConfiguration();
    await this.testFileUploadSecurity();
    await this.testRateLimiting();
    await this.testDependencyVulnerabilities();
    await this.testSecurityHeaders();

    this.printSummary();
  }

  /**
   * ÁµêÊûú„Çµ„Éû„É™„ÉºÂá∫Âäõ
   */
  printSummary() {
    console.log('\n' + '=' .repeat(60));
    console.log('üîí „Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÜ„Çπ„ÉàÁµêÊûú„Çµ„Éû„É™„Éº');
    console.log('=' .repeat(60));

    const passedTests = this.results.filter(r => r.level === 'PASS').length;
    const totalTests = this.results.length;

    console.log(`‚úÖ ÈÄöÈÅé: ${passedTests}/${totalTests}`);
    console.log(`‚ö†Ô∏è  Ë≠¶Âëä: ${this.warnings.length}`);
    console.log(`üö® ÈáçÂ§ß„Å™ÂïèÈ°å: ${this.criticalIssues.length}`);

    if (this.criticalIssues.length > 0) {
      console.log('\nüö® ÈáçÂ§ß„Å™ÂïèÈ°å:');
      this.criticalIssues.forEach(issue => {
        console.log(`   - ${issue.test}: ${issue.details}`);
      });
    }

    if (this.warnings.length > 0) {
      console.log('\n‚ö†Ô∏è  Ë≠¶Âëä:');
      this.warnings.forEach(warning => {
        console.log(`   - ${warning.test}: ${warning.details}`);
      });
    }

    console.log('\n' + '=' .repeat(60));

    if (this.criticalIssues.length === 0) {
      console.log('üéâ ÈáçÂ§ß„Å™„Çª„Ç≠„É•„É™„ÉÜ„Ç£ÂïèÈ°å„ÅØË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„ÅüÔºÅ');
      console.log('üöÄ Êú¨Áï™„Éá„Éó„É≠„Ç§„ÅÆÊ∫ñÂÇô„Åå„Åß„Åç„Å¶„ÅÑ„Åæ„Åô„ÄÇ');
    } else {
      console.log('‚ö†Ô∏è  Êú¨Áï™„Éá„Éó„É≠„Ç§Ââç„Å´ÈáçÂ§ß„Å™ÂïèÈ°å„Çí‰øÆÊ≠£„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
    }
  }
}

// „É°„Ç§„É≥ÂÆüË°å
const tester = new SecurityTester();
tester.runAllTests().catch(console.error);